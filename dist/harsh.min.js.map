{"version":3,"sources":["node_modules/browser-pack/_prelude.js","index.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","harsh","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","createSalts","base","salts","push","Math","floor","random","pow","toString","createHash","id","hash","pieces","concat","_toConsumableArray","hashString","index","splice","ids","TypeError","hashes","map","hashish","bunch","num","reverse","re","RegExp","join","reversed","stripped","replace","parseInt"],"mappings":"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","file":"harsh.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict'\n\nconst createSalts = (n, base) => {\n  let salts = []\n  for (let i = 0; i < n; i++) {\n    salts.push(Math.floor(Math.random() * Math.pow(10, 6)).toString(base))\n  }\n  return salts\n}\n\nconst createHash = (id, salts, base) => {\n  const hash = id.toString(base)\n  let pieces = [...salts, hash]\n  let hashString = ''\n  do {\n    let index = Math.floor(Math.random() * pieces.length)\n    hashString += pieces[index]\n    pieces.splice(index, 1)\n  } while (pieces.length)\n  return hashString\n}\n\nmodule.exports = {\n  /**\n   * Takes a number and a radix base, outputs a salted hash\n   * @param  {Array} ids   list of ids to hash\n   * @param {Number} n number of salts to add to the hash\n   * @param  {Number} base radix base, 16 through 36 allowed\n   * @return {Object}      a hash object containing the hashes as well as info needed to reverse them\n   */\n  hash (ids, n, base) {\n    ids = ids || [Math.floor(Math.random() * 100)]\n    n = n || 2\n    base = base || 36\n\n    if (!ids.splice) {\n      throw new TypeError('The ids argument should be an array of numbers')\n    }\n    if (typeof n !== 'number' || n < 0) {\n      throw new TypeError('The number of salts should be a positive integer')\n    }\n    if (typeof base !== 'number' || base < 16 || base > 36) {\n      throw new TypeError('The base should be a number between 16 and 36')\n    }\n\n    // Create the salts. This will be the same for all hashes\n    const salts = createSalts(n, base)\n\n    // Combine the salts and the actual\n    let hashes = ids.map((id) => {\n      if (typeof id !== 'number') {\n        throw new TypeError('The ids you\\'re hashing should only be numbers')\n      }\n      return createHash(id, salts, base)\n    })\n\n    return {\n      ids: ids,\n      hashes: hashes,\n      salts: salts,\n      base: base\n    }\n  },\n  /**\n   * Simplified API to just return a single token using defaults\n   * @return {String} a hash\n   */\n  hashish () {\n    return createHash(\n      [Math.floor(Math.random() * 100)],\n      createSalts(2, 36),\n      36\n    )\n  },\n  /**\n   * Creates a specified number of random tokens\n   * @param  {Number} num  number of tokens to create\n   * @param  {Number} n    number of salts to add to each hash\n   * @param  {Number} base radix base, 16 through 36 allowed\n   * @return {Object}      a hash object containing the hashes as well as info needed to reverse them\n   */\n  bunch (num, n, base) {\n    num = num || 1\n    n = n || 2\n    base = base || 36\n\n    if (typeof num !== 'number') {\n      throw new TypeError('The num should be a number')\n    }\n    if (typeof n !== 'number' || n < 0) {\n      throw new TypeError('The number of salts should be a positive integer')\n    }\n    if (typeof base !== 'number' || base < 16 || base > 36) {\n      throw new TypeError('The base should be a number between 16 and 36')\n    }\n\n    // Create the ids\n    let ids = []\n    for (let i = 0; i < num; i++) {\n      ids.push(Math.floor(Math.random() * Math.pow(10, num.toString(10).length + 2)))\n    }\n\n    // Create the salts. This will be the same for all hashes\n    const salts = createSalts(n, base)\n\n    // Combine the salts and the actual\n    let hashes = ids.map((id) => {\n      return createHash(id, salts, base)\n    })\n\n    return {\n      ids: ids,\n      hashes: hashes,\n      salts: salts,\n      base: base\n    }\n  },\n  /**\n   * Takes a string and necessary components to reverse back to the original number\n   * @param  {Array} hashes   list of hashes to reverse\n   * @param  {Array} salts  list of salts applied to the list (provided from `hash`)\n   * @param  {base} base     radix base, 16 through 36 allowed\n   * @return {Array}          list of reversed hashes\n   */\n  reverse (hashes, salts, base) {\n    base = base || 36\n\n    if (!hashes.splice) {\n      throw new TypeError('The hashes argument should be an array of hashes provided by the hash method')\n    }\n    if (!salts.splice) {\n      throw new TypeError('The salts argument should be an array of salt strings provided by the hash method')\n    }\n    if (typeof base !== 'number' || base < 16 || base > 36) {\n      throw new TypeError('The base should be a number between 16 and 36')\n    }\n    const re = new RegExp(salts.join('|'), 'g')\n\n    let reversed = hashes.map((hash) => {\n      if (typeof hash !== 'string') {\n        throw new TypeError('The hashes you\\'re reversing should only be strings')\n      }\n      let stripped = hash.replace(re, '')\n      return parseInt(stripped, base)\n    })\n\n    return reversed\n  }\n}\n"]}